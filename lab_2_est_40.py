# -*- coding: utf-8 -*-
"""Lab 2 EST-40

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ANhwrcRXe3RBpO7Ue1sa__kdUu6s3vlX
"""

from google.colab import files
import math
import numpy as np
import sympy as sp

uploaded = files.upload()  # Vai abrir um botão para escolher o arquivo

nome_arquivo = list(uploaded.keys())[0]

with open(nome_arquivo, "r") as arquivo:
    linhas = arquivo.readlines()

secoes = {}         # Dicionário com os dados por seção
nome_secao = None   # Nome da seção atual

for linha in linhas:
    linha = linha.strip()

    if not linha:
        continue  # Pula linha em branco

    if linha.startswith("*"):
        nome_secao = linha.split()[0][1:]  # Remove o asterisco e pega o nome da seção
        secoes[nome_secao] = []            # Inicializa a lista da nova seção
    else:
        valores = linha.split(",")         # Divide a linha pelos valores separados por vírgula
        secoes[nome_secao].append(valores) # Armazena na seção atual

def converter_valores(linha):
    resultado = []
    for valor in linha:
        try:
            if "." in valor:
                resultado.append(float(valor))
            else:
                resultado.append(int(valor))
        except:
            resultado.append(valor.strip())  # mantém como string se não der pra converter
    return resultado

points = [converter_valores(linha) for linha in secoes.get("POINTS", [])]
curves = [converter_valores(linha) for linha in secoes.get("CURVES", [])]
materials = [converter_valores(linha) for linha in secoes.get("MATERIALS", [])]
properties = [converter_valores(linha) for linha in secoes.get("PROPERTIES", [])]
mesh = [converter_valores(linha) for linha in secoes.get("MESH", [])]
point_loads = [converter_valores(linha) for linha in secoes.get("POINT_LOADS", [])]
dist_loads = [converter_valores(linha) for linha in secoes.get("DIST_LOADS", [])]
bc = [converter_valores(linha) for linha in secoes.get("BC", [])]

# POINTS
points = [converter_valores(linha) for linha in secoes.get("POINTS", [])]
coordenadas = {p[0]: (p[1], p[2]) for p in points}

# CURVES
curves = [converter_valores(linha) for linha in secoes.get("CURVES", [])]
curvas = {c[0]: (c[1], c[2]) for c in curves}

# MATERIALS
materials = [converter_valores(linha) for linha in secoes.get("MATERIALS", [])]
materiais = {m[0]: (m[1], m[2]) for m in materials}

# PROPERTIES
properties = [converter_valores(linha) for linha in secoes.get("PROPERTIES", [])]
propriedades = {p[0]: (p[1], p[2], p[3]) for p in properties}  # inclui A e I

# MESH
mesh = [converter_valores(linha) for linha in secoes.get("MESH", [])]
elemento = {m[0]: (m[1], m[2]) for m in mesh}  # curva_id: (prop_id, num_elem)

# POINT_LOADS — pode ter várias por ponto!
point_loads = [converter_valores(linha) for linha in secoes.get("POINT_LOADS", [])]
forcas = {}
for p in point_loads:
    ponto_id, gdl, valor = p[1], p[2], p[3]
    if ponto_id not in forcas:
        forcas[ponto_id] = []
    forcas[ponto_id].append((gdl, valor))

# DIST_LOADS — 1 por curva
dist_loads = [converter_valores(linha) for linha in secoes.get("DIST_LOADS", [])]
carga_distribuida = {p[1]: (p[2], p[3], p[4]) for p in dist_loads}  # curva_id: (val_ini, val_fim, direção)

# BC — pode ter várias por ponto!
bc = [converter_valores(linha) for linha in secoes.get("BC", [])]
condicoes_de_contorno = {}
for p in bc:
    ponto_id, gdl, valor = p[0], p[1], p[2]
    if ponto_id not in condicoes_de_contorno:
        condicoes_de_contorno[ponto_id] = []
    condicoes_de_contorno[ponto_id].append((gdl, valor))

novo_id = max(coordenadas.keys()) + 1

x = sp.Symbol('x')

matrizes_Keg = {}
vetores_feg = {}

todos_subelementos = []


for curva in curves:
    n, ini, fim = curva
    x1, y1 = coordenadas[ini]
    x2, y2 = coordenadas[fim]
    L = ((x2 - x1)**2 + (y2 - y1)**2)**(0.5)
    c = (x2 - x1) / L
    s = (y2 - y1) / L
    prop_id, num_elem = elemento[n]
    mat_id = propriedades[prop_id][0]
    E, nu = materiais[mat_id]
    _, A, I = propriedades[prop_id]
    dx = (x2 - x1)/num_elem
    dy = (y2 -y1)/num_elem

    # Gera pontos intermediários
    pontos_local = [ini]
    for i in range(1, num_elem):
        xi = x1 + i * dx
        yi = y1 + i * dy
        coordenadas[novo_id] = (xi, yi)
        pontos_local.append(novo_id)
        novo_id += 1
    pontos_local.append(fim)

    # Gera subelementos
    for i in range(num_elem):
      no_i = pontos_local[i]
      no_f = pontos_local[i+1]
      x_ini = coordenadas[no_i][0]
      x_fim = coordenadas[no_f][0]

      Le = L / num_elem
      Ee, Ae, Ie = E, A, I

      todos_subelementos.append((no_i, no_f, prop_id, Ee, Ae, Ie, Le))

      # Matriz de rotação
      R = np.array([
          [c, -s, 0, 0, 0, 0],
          [s,  c, 0, 0, 0, 0],
          [0,  0, 1, 0, 0, 0],
          [0,  0, 0, c, -s, 0],
          [0,  0, 0, s,  c, 0],
          [0,  0, 0, 0,  0, 1]
      ])

      u = Ae * Le**2 / (2 * Ie)

      K_e_l = (2 * ((Ee * Ie) / Le**3)) * np.array([
          [u, 0, 0, -u, 0, 0],
          [0, 6, 3*Le, 0, -6, 3*Le],
          [0, 3*Le, 2*Le**2, 0, -3*Le, Le**2],
          [-u, 0, 0, u, 0, 0],
          [0, -6, -3*Le, 0, 6, -3*Le],
          [0, 3*Le, Le**2, 0, -3*Le, 2*Le**2]
      ])

      K_e_g = R @ K_e_l @ R.T

      # Funções de forma com Le do subelemento
      psi1 = 1 - x/Le
      psi2 = x/Le
      phi1 = 1 - 3*(x/Le)**2 + 2*(x/Le)**3
      phi2 = x*(1 - x/Le)**2
      phi3 = 3*(x/Le)**2 - 2*(x/Le)**3
      phi4 = x*(x/Le)*((x/Le) - 1)

      # Força distribuída
      if n in carga_distribuida:
          p0, p1, direcao = carga_distribuida[n]

          funcao = ((p1 - p0)/L)*x + p0

          pini = float(funcao.subs(x,x_ini))
          pfim = float(funcao.subs(x,x_fim))

          dist = ((pfim - pini)/Le)*x + pini

          if direcao == 't':
              p = dist
              q = 0
          elif direcao == 'l':
              q = dist
              p = 0
          elif direcao == 'y':
              p = (c)*dist
              q = s*dist
          elif direcao == 'x':
              p = (-s)*dist
              q = c*dist
          else:
              p = q = 0

          f_e_l = np.array([
              [sp.integrate(psi1 * q, (x, 0, Le))],
              [sp.integrate(phi1 * p, (x, 0, Le))],
              [sp.integrate(phi2 * p, (x, 0, Le))],
              [sp.integrate(psi2 * q, (x, 0, Le))],
              [sp.integrate(phi3 * p, (x, 0, Le))],
              [sp.integrate(phi4 * p, (x, 0, Le))]
          ], dtype=object)
      else:
          f_e_l = np.zeros((6, 1))

      f_e_g = R @ f_e_l

      id_elem = len(matrizes_Keg)
      matrizes_Keg[id_elem] = K_e_g
      vetores_feg[id_elem] = f_e_g

# K_global e f_global

n_nos = max(coordenadas.keys())

K_global = np.zeros((3 * n_nos, 3 * n_nos))
f_global = np.zeros((3 * n_nos, 1))

for id_elem in matrizes_Keg:
    K_e_g = matrizes_Keg[id_elem]
    f_e_g = vetores_feg[id_elem]
    no_i, no_f, *_ = todos_subelementos[id_elem]

    gdl_globais = [
    3*(no_i - 1),     # u do nó inicial
    3*(no_i - 1) + 1, # v do nó inicial
    3*(no_i - 1) + 2, # θ do nó inicial
    3*(no_f - 1),     # u do nó final
    3*(no_f - 1) + 1, # v do nó final
    3*(no_f - 1) + 2  # θ do nó final
    ]


    for i in range(6):
      for j in range(6):
        K_global[gdl_globais[i], gdl_globais[j]] = K_global[gdl_globais[i], gdl_globais[j]] + K_e_g[i,j]
      f_global[gdl_globais[i], 0] = f_global[gdl_globais[i], 0] + f_e_g[i,0]

for no, lista in forcas.items():
    for gdl_no, valor in lista:
        gdl_global = 3 * (no - 1) + (gdl_no - 1)
        f_global[gdl_global, 0] += valor

K_original = K_global.copy()
f_original = f_global.copy()

# Aplicar condição de contorno

for linha in bc:
    no, gdl_local, valor = linha

    gdl_global = 3 * (no - 1) + (gdl_local - 1)

    # Zerar linha e coluna
    K_global[gdl_global, :] = 0
    K_global[gdl_global, gdl_global] = 1

    # Definir valor no vetor de forças
    f_global[gdl_global, 0] = valor

deslocamentos = np.linalg.solve(K_global, f_global)

resultados_nodais = {}

for no in coordenadas.keys():
  gdl_u = 3*(no-1)
  gdl_v = 3*(no-1)+1
  gdl_theta = 3*(no-1)+2
  u = deslocamentos[gdl_u, 0]
  v = deslocamentos[gdl_v, 0]
  theta = deslocamentos[gdl_theta, 0]

  resultados_nodais[no] = (u, v, theta)

resultados_elementos = {}

for i, sub in enumerate(todos_subelementos):
  no_ini, no_fim, prop_id, Ee, Ae, Ie, Le = sub
  x1, y1 = coordenadas[no_ini]
  x2, y2 = coordenadas[no_fim]
  L = ((x2 - x1)**2 + (y2 - y1)**2)**(0.5)
  c = (x2 - x1) / L
  s = (y2 - y1) / L
  R = np.array([
          [c, -s, 0, 0, 0, 0],
          [s,  c, 0, 0, 0, 0],
          [0,  0, 1, 0, 0, 0],
          [0,  0, 0, c, -s, 0],
          [0,  0, 0, s,  c, 0],
          [0,  0, 0, 0,  0, 1]
      ])
  R_inv = np.linalg.inv(R)
  gdl_globais = [
    3*(no_ini - 1),     # u do nó inicial
    3*(no_ini - 1) + 1, # v do nó inicial
    3*(no_ini - 1) + 2, # θ do nó inicial
    3*(no_fim - 1),     # u do nó final
    3*(no_fim - 1) + 1, # v do nó final
    3*(no_fim - 1) + 2  # θ do nó final
    ]
  u_e_g = deslocamentos[gdl_globais,0].reshape((6,1))
  u_e_l = R_inv @ u_e_g
  u1 = u_e_l[0,0]
  v1 = u_e_l[1,0]
  theta1 = u_e_l[2,0]
  u2 = u_e_l[3,0]
  v2 = u_e_l[4,0]
  theta2 = u_e_l[5,0]

  fx1 = fx2 = Ee*Ae*(u2-u1)/Le

  M_expr = Ee * Ie * (
    v1 * (12*x/Le**3 - 6/Le**2) +
    theta1 * (6*x/Le**2 - 4/Le) +
    v2 * (-12*x/Le**3 + 6/Le**2) +
    theta2 * (6*x/Le**2 - 2/Le)
  )

  V_expr = Ee * Ie * (
    v1 * (12/Le**3) +
    theta1 * (6/Le**2) +
    v2 * (-12/Le**3) +
    theta2 * (6/Le**2)
  )
  m1 = float(M_expr.subs(x,0))
  m2 = float(M_expr.subs(x,Le))

  fy1 = V_expr
  fy2 = V_expr

  resultados_elementos[i] = (fx1, fy1, m1, fx2, fy2, m2)

r = K_original @ deslocamentos - f_original

reacoes = {}
for linha in bc:
    no, gdl_local, valor = linha
    gdl_global = 3 * (no - 1) + (gdl_local - 1)
    reacoes[(no, gdl_local)] = r[gdl_global, 0]

def gerar_relatorio_saida(nome_arquivo_entrada, points, curves, bc, resultados_nodais=None, resultados_elementos=None, reacoes=None, nome_saida="saida.txt"):
    with open(nome_saida, "w") as f:
        f.write("Resultado da Simulação\n\n")
        f.write(f"Arquivo de Entrada: {nome_arquivo_entrada}\n\n\n")

        f.write("------------------ Resultados Nodais ------------------\n")
        f.write("|   Nó|              u|              v|          theta|\n")
        f.write("-------------------------------------------------------\n")
        for no in sorted(coordenadas, key=lambda k: coordenadas[k][0]):
            u, v, theta = resultados_nodais.get(no, (0.0, 0.0, 0.0))
            f.write(f"|{no:6}|{u:14.7f}|{v:14.7f}|{theta:16.6f}|\n")
        f.write("-------------------------------------------------------\n\n\n")

        f.write("------------------------------------------------------ Resultados por Elemento ------------------------------------------------------\n")
        f.write("| Elemento|  Nó Inicial|        Força x|        Força y|        Momento|    Nó Final|        Força x|        Força y|        Momento|\n")
        f.write("-------------------------------------------------------------------------------------------------------------------------------------\n")
        for i, sub in enumerate(todos_subelementos):
            no_ini, no_fim, *_ = sub
            dados = resultados_elementos.get(i, (0.0, 0.0, 0.0, 0.0, 0.0, 0.0))
            fx1, fy1, m1, fx2, fy2, m2 = dados
            f.write(f"|{i+1:9}|{no_ini:12}|{fx1:15.4f}|{fy1:15.4f}|{m1:15.4f}|{no_fim:12}|{fx2:15.4f}|{fy2:15.4f}|{m2:15.4f}|\n")
        f.write("-------------------------------------------------------------------------------------------------------------------------------------\n\n\n")

        f.write("------ Forças de Reação ------\n")
        f.write("|   Nó|   GDL|          Value|\n")
        f.write("------------------------------\n")
        for linha in bc:
            no = linha[0]
            gdl = linha[1]
            valor = reacoes.get((no, gdl), 0.0)
            f.write(f"|{no:5}|{gdl:6}|{valor:15.4f}|\n")
        f.write("------------------------------\n")

gerar_relatorio_saida(nome_arquivo, points, curves, bc, resultados_nodais, resultados_elementos, reacoes)
files.download("saida.txt")